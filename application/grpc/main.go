package main

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	investorv1 "github.com/iainvm/deposits/application/grpc/gen/investors/v1"         // generated by protoc-gen-go
	"github.com/iainvm/deposits/application/grpc/gen/investors/v1/investorsv1connect" // generated by protoc-gen-connect-go
	"github.com/iainvm/deposits/common/postgres"
	"github.com/iainvm/deposits/internal/investors"
	store "github.com/iainvm/deposits/internal/investors/postgres"
	"github.com/sethvargo/go-envconfig"
)

type DBConfig struct {
	Host     string `env:"HOST"`
	Port     string `env:"PORT, default=5432"`
	User     string `env:"USER"`
	Password string `env:"PASSWORD"` // TODO: this would be pulled from a secrets vault
	Name     string `env:"NAME"`
}

type Config struct {
	Port     string   `env:"PORT, default=8080"`
	DBConfig DBConfig `env:", prefix=DB_"`
}

type InvestorsHandler struct {
	investorsService *investors.Service
	log              *slog.Logger
}

func (h *InvestorsHandler) Onboard(ctx context.Context, req *connect.Request[investorv1.OnboardRequest]) (*connect.Response[investorv1.OnboardResponse], error) {
	h.log.With("header", req.Header()).With("request", req.Msg).Info("Onboard Called")

	// Create investor
	investor, err := h.investorsService.Create(ctx, req.Msg.Name)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	// Create response
	res := connect.NewResponse(&investorv1.OnboardResponse{
		Id:   investor.Id.String(),
		Name: investor.Name.String(),
	})
	res.Header().Set("Investor-Version", "v1")
	return res, nil
}

func main() {
	// Logger
	ctx := context.Background()
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelDebug,
	}))
	slog.SetDefault(logger)

	// Parse Env Vars
	var config Config
	err := envconfig.Process(ctx, &config)
	if err != nil {
		logger.With("error", err).Error("failed to parse server configuration")
		panic(fmt.Errorf("failed to parse server configuration: %w", err))
	}
	logger.Debug("Config Processed", "Config", config)

	// DB
	dataSource := postgres.NewDataSource(
		config.DBConfig.Host,
		config.DBConfig.Port,
		config.DBConfig.User,
		config.DBConfig.Password,
		config.DBConfig.Name,
		false,
	)
	db, err := postgres.Connect(dataSource)
	if err != nil {
		logger.With("error", err).Error("failed to connect to DB")
		panic(fmt.Errorf("failed to connect to DB: %w", err))
	}
	logger.With("host", config.DBConfig.Host).With("port", config.DBConfig.Port).Info("Connected to DB")

	// Init servers
	investorsStore := store.NewStore(
		db,
	)
	investorsService := investors.NewService(
		investorsStore,
	)
	investorsServer := &InvestorsHandler{
		investorsService: investorsService,
		log:              logger,
	}

	// Register handlers
	mux := http.NewServeMux()
	path, handler := investorsv1connect.NewInvestorsServiceHandler(investorsServer)
	mux.Handle(path, handler)

	// Listen
	logger.Info("Starting listener", "port", config.Port)
	http.ListenAndServe(
		fmt.Sprintf(":%s", config.Port),
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
